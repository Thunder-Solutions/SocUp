# Component Development Guidelines

Can probably pull some things from here: [Custom Element Best Practices | Web Fundamentals | Google Developers](https://developers.google.com/web/fundamentals/web-components/best-practices)

- **Break components into layers/types - semantic and “presentation”**
  - This was primarily coming out of a combination of my own intuition plus [common suggestions from the W3C for Accessibility](https://www.w3.org/TR/2008/WD-WCAG20-TECHS-20081103/G140).
  - After reading articles on how folks commonly break these layers down and name them in Angular specifically (like [this one](https://medium.com/nonstopio/angular-architecture-pattern-bc69f9c3372c)), I found that the semantic/content layer is often called the “abstraction” layer.
- **Avoid leaking presentation details via your component's API**. Naming for “presentation” components and their inputs should not actually represent presentation/design decisions. Names which are similar to CSS properties like spacing, positioning, colors, etc are not descriptions of content - they’re just defining how something should appear on that line. Like all other components, presentation components are simply **reusable semantics** which happen to have presentation details implemented under the hood - including ADA-compliance/WAI-ARIA functionality for unsighted users. In fact, these requirements may change the API of our components in some cases, since we may need text in places where we originally had, say, just an icon or other image. We’ll need to take these into consideration even before we get to full ADA compliance so our component APIs don’t change. But, these inputs also follow the same rule: Like with CSS concerns, these don’t map one-to-one with ARIA properties, either.
  - Ex. `<ch-button align="right">` describes how that component appears, which means we have a leaky abstraction on our hands (not good)
  - Ex. `<ch-button slot="actions">` places this component within the context of some parent container (maybe a modal), which has a section where content is potentially aligned to the right via CSS. With this approach, we’ve just dodged the need to define exactly how this is styled on this line and it can change freely behind our API. That entire grouping of content can be moved to the top, side, etc. of that modal or the buttons in that group can be freely aligned to the left later.
  - Ex. For ARIA, `<my-component label="Some Text">` may make sense to map directly to `aria-label="Some Text"` in the template but `role="presentation"` or `aria-hidden="true"` aren’t pieces we would want to expose in our API.
  - This will still happen at times. Joel Spolsky (one of the creators of StackOverflow) came up with the term “[leaky abstraction](https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/)” and, though he claims that “**All non-trivial abstractions, to some degree, are leaky.**”, that doesn’t mean we don’t still try to keep things manageable, imo.
  - It’s still perfectly possible to “leak” details and still have maintainable software…but we have to limit those leaks with some type of guidelines.
  - Maybe we can explicitly call out and identify the exceptions to provide consistency. For our company’s size, I find this to be very important to get right, though. We can’t manage separate teams without static analysis and/or SOME way of automatically preventing people from doing things in the obviously “wrong” ways
  - Put simply…Once we spring a leak, it’s up to the parent container to manage the issue now. `<ch-button align="right">` converts the parent component into a “presentation” component that UX + eng now has to maintain together on top of the `ch-button` itself because design decisions were made from the outside
- I haven’t found a specific need to do this but, **if we find a need for components with properties or component names which are related to design, we should find a way to scope them** (This is basically what I said about “leaky abstractions” in previous comments) to only be used within our presentation component templates, behind a more semantic/content-oriented (design-agnostic) API. The same goes for any kind of utility classes - these have the same list of cons.
- **Some components will be more generic than others**. Occasionally, a component will exist as a one-off thing - like layout or other styling which isn’t shared anywhere else. These situations do include a reason to appear this way, though, and we can still codify that reasoning in terms of the content it’s describing (at least, I haven’t run into a situation where this wasn’t possible to figure out).
  - Ex. Even if we only show a cart or the primary navigation in a single place, we may still have one or more reasons to factor that out into its own component. If it contributes to design, we can move this into a shared presentation folder, even though it isn’t “shared”.
- **Put all presentation components into a single location** - This may not always make sense. It’s still a recommendation for most cases, though. From an engineering perspective, locating design decisions in a single place gains us the benefits of both information hiding and cohesion. From a design perspective, changes are easier to request with less turnaround time.
  - Ex. We could use a folder structure for components with CSS and/or divs and spans in the template (which also only exist for the sake of presentation) `shared/presentation/button/button.component.ts` which is separate from shared higher-level/”molecule” components folder-wise but all shared components could still be exported from the same `index.ts` file.
- **Only use classes in shared presentation components** - Angular and other frameworks can grab element/component references via other means. If we still have classes outside of these components, it should be nice and obvious that we have leaked presentation details outside of our presentation layer.
- **For shared components, avoid complex input data types like objects/arrays (where possible).** This definitely doesn’t make sense everywhere but, if a component is an atom/low-level “presentation” component, we can generally lean towards splitting components into two or more related components within the same module (Ex. List and ListItem within the List module). This simplifies and moves code into the template - we don't need to import types just to use a component, since primitives are already defined. If we want to demonstrate in Storybook, or share these components in other applications eventually, this will also make things far less complex, since we don't need nested fields for object properties. Finally, we run less risk of mutating data passed by reference, causing unexpected side effects outside of the component (Ex. vx-autocomplete and its array mutation issues)
  - (At very least, I’ve noticed this helps with hooking client-side routing into individual navigation items)
- **If we must use objects/arrays for input data, treat input data as immutable, even if JavaScript doesn’t**. If a value needs to change, fire an event and maybe change some internal, cloned value instead. See note above about mutation issues
- **Map ng-content selectors (if used) using native-web-component-compatible slot attributes** - this keeps the shape of our components the same, regardless of what tech we use later on. (This should also apply to other frameworks)
  - I learned after this that Angular supports [ShadowDOM CSS/view encapsulation](https://angular.io/api/core/ViewEncapsulation#ShadowDom). So this is important for even switching between those two options within Angular, ignoring the native web components
- Breaking down slots - `<ch-page><p slot="copyright">© 2021 Dsco® All Rights Reserved.</p></ch-page> rather than <ch-page><p slot="footer">© 2021 Dsco® All Rights Reserved.</p></ch-page>` (“footer” specifies where content is placed, thus implies a certain layout)

## CSS-specific

- **BEM** (Not important if we are using Shadow DOM encapsulation) - As long as class names aren't being used outside of the presentation layer, we can name these whatever we want inside the presentation components' templates. That said, it makes it easier to map an element back to its parent component if we follow a naming convention, like BEM. This also decreases the complexity of CSS selectors.
  - Ex. a `<div>` in a modal component’s template might have `class="modal__backdrop"` on it - this would be very easy to work backward from what is visible in DevTools to the component code that defines it.
- Use `gap` and either `display: flex` or `display: grid` on the parent element instead of margins on child elements for layout - this removes most confusing layouts surrounding negative margins
- Use default margins for any components that could make sense alongside paragraphs, headings, etc.
- Override those default margins with `:host-context()` when nested within certain other components. We’ve found one particular pattern very useful:
  - ```css
    modal__body ::ng-deep :first-child {
    	margin-block-start: 0;
    }
    modal__body ::ng-deep :last-child {
    	margin-block-end: 0;
    }
    ```
  - These specific approaches might be argued against. I’ve found success with this approach since we also have default styles to fight (for `<p>` tags and such)
  - Ex. We need some way to handle: `<x-page><p>Hi</p></x-page>`
  - If `<x-page>` has default padding on its body, the margins that come on `<p>` tags by default add to that negative space ([like this](https://jsfiddle.net/j8vhqckw/))
  - Overriding the margins of the first and last child elements fixes that problem ([like this](https://jsfiddle.net/j8vhqckw/1/))
- Override styles depending on where a component is placed within other “shared”/presentation components. (NOT on specific pages, though)
  - Ex. `:host-context(ch-primary-nav) .input__input { color: #fff }` (style input differently when it’s in our primary nav, because the background color is dark)
  - This one was contentious. There are other approaches but this was an attempt to solve the leaky abstraction problem by moving the design decisions inside, rather than have them placed into the parent component. The other approaches went with a “pass the styling downward” approach which requires the parent component to become a place where design decisions are now made (more for UX + eng to maintain)
  - It would theoretically also be possible to use [shadow parts](https://developer.mozilla.org/en-US/docs/Web/CSS/::part) here but I’d only recommend shadow parts if we aren’t exposing that component outside the presentation layer in our app
- Negative margins can still be used to offset default padding. For example, a modal has padding around the modal body content, but there may be cases where certain components want to override that to expand up to the borders of the modal. This would be another use case for `:host-context()` (and possibly a CSS variable to pass down that padding value)
  - On second thought, maybe the best solution to get specific values (instead of CSS variables) would be mixins/variables (Ex. via SCSS) exported from the parent and imported into the child to combine within a `:host-context` selector. CSS variables enable the component users to intercept and change styles outside of the components. If we can avoid that, it would probably be best.
- Avoid specific width & height values when possible. Sometimes this isn’t possible, but in most cases we can utilize the nature of grids, blocks, padding, gap, etc.
  - When I say "sometimes this isn't possible", I’m specifically thinking about cases where the content can’t be reliably used to determine the width/height.
  - Ex. A nav link where the width of the items change because of an added arrow that appears when a user is on that particular page. (Saw this case in the SLA page menu on the left)
  - Just note that this is a strange exception that probably calls for UX to rethink their design to keep it easily maintainable.

## Component's API

- Component name/selector (Ex. `ch-modal`)
- Input names & types (Ex. internal `@Input open = false;` / external `<ch-modal open>...</ch-modal>`)
- Slot names (Ex. `slot="actions"` or `slot="title"`)
- Prefer composition over inheritance. In this context, that means that it’s usually better to provide a set of components with smaller scopes that can be used together, rather than provide a single larger component that uses smaller components internally in specific ways. When we have these larger “opinionated” components, they tend to accumulate a ton of parameters to allow controlling all of the details for various different use cases, or we see copies of them made with names like LargeComponentWithThisOneDifference. If there’s a pattern where the set of smaller components is used often in the same or similar ways, the tradeoffs usually point to copy/pasting the way they were used together elsewhere, in order to preserve the ability to make use-case specific adjustments.
